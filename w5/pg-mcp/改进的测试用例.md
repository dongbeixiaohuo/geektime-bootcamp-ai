# PG-MCP 功能改进测试指南

## 使用说明

本文档提供每个改进功能的**手动测试步骤**，无需深入代码即可验证。每个测试包含：
- 前置条件（环境/配置准备）
- 测试步骤（具体操作）
- 预期结果（通过标准）
- 失败表现（问题特征）

---

## 一、多数据库与安全控制

### 1.1 多数据库支持

#### 测试场景 A：配置多个数据库后能分别查询

**前置条件**
```bash
# 准备两个测试数据库（可以是同一个 PostgreSQL 实例的不同库）
# 假设有 db_sales 和 db_inventory 两个库

# 配置环境变量（改进后应支持）
export DATABASES='[
  {"name": "sales", "host": "localhost", "port": 5432, "database": "db_sales", "user": "test", "password": "test"},
  {"name": "inventory", "host": "localhost", "port": 5432, "database": "db_inventory", "user": "test", "password": "test"}
]'
export DEFAULT_DATABASE=sales
```

**测试步骤**
1. 启动 PG-MCP 服务
2. 发送查询请求，指定 `database: "sales"`
3. 发送查询请求，指定 `database: "inventory"`
4. 发送查询请求，不指定 database

**预期结果**
- 步骤2：查询在 db_sales 库执行，返回该库的数据
- 步骤3：查询在 db_inventory 库执行，返回该库的数据
- 步骤4：查询在默认库 sales 执行

**失败表现**
- 报错"Multiple databases available, please specify which to query"但已指定了库
- 所有请求都落在同一个库，忽略 database 参数
- 启动时报配置解析错误

---

#### 测试场景 B：请求不存在的数据库时报错

**前置条件**
- 同场景A，配置了 sales 和 inventory 两个库

**测试步骤**
1. 发送查询请求，指定 `database: "nonexistent"`

**预期结果**
```json
{
  "error": "DatabaseError",
  "message": "Database 'nonexistent' not found",
  "details": {
    "requested_database": "nonexistent",
    "available_databases": ["sales", "inventory"]
  }
}
```

**失败表现**
- 返回通用错误，没有列出可用数据库
- 静默使用默认库而不是报错

---

#### 测试场景 C：单库配置向后兼容

**前置条件**
```bash
# 使用原有的单库配置方式
export DATABASE_HOST=localhost
export DATABASE_PORT=5432
export DATABASE_NAME=testdb
export DATABASE_USER=test
export DATABASE_PASSWORD=test
# 不设置 DATABASES 环境变量
```

**测试步骤**
1. 启动 PG-MCP 服务
2. 发送查询请求，不指定 database

**预期结果**
- 服务正常启动
- 查询正常执行，行为与改进前一致

**失败表现**
- 启动报错要求配置 DATABASES
- 查询报错"No databases configured"

---

### 1.2 表/列级访问限制

#### 测试场景 A：封禁表后无法查询该表

**前置条件**
```bash
# 假设数据库中有 users、orders、audit_log 三张表
# 配置封禁 users 和 audit_log 表
export SECURITY_BLOCKED_TABLES=users,audit_log
```

**测试步骤**
1. 重启服务使配置生效
2. 发送查询："查询所有订单"（应该查 orders 表）
3. 发送查询："查询所有用户"（应该查 users 表）
4. 发送查询："查询审计日志"（应该查 audit_log 表）
5. 发送查询："查询订单及用户信息"（可能 JOIN users 表）

**预期结果**
- 步骤2：正常返回 orders 表数据
- 步骤3：返回安全错误
  ```json
  {
    "error": "SecurityViolationError",
    "message": "Access to table 'users' is not allowed"
  }
  ```
- 步骤4：返回安全错误，提示 audit_log 被封禁
- 步骤5：返回安全错误（因为生成的 SQL 涉及 users 表）

**失败表现**
- 能查询到 users 表数据
- 报错信息不明确，不知道是哪个表被封禁

---

#### 测试场景 B：封禁特定列后无法查询该列

**前置条件**
```bash
# 封禁 users 表的 password 和 ssn 列
export SECURITY_BLOCKED_COLUMNS=users.password,users.ssn
# 注意：这里不封禁整个 users 表
unset SECURITY_BLOCKED_TABLES
```

**测试步骤**
1. 重启服务
2. 发送查询："查询用户的姓名和邮箱"
3. 发送查询："查询用户的密码"
4. 发送查询："SELECT * FROM users"（通过自然语言触发）
5. 发送查询："查询用户的社保号"

**预期结果**
- 步骤2：正常返回（name, email 不在封禁列表）
- 步骤3：返回安全错误
  ```json
  {
    "error": "SecurityViolationError", 
    "message": "Access to column 'users.password' is not allowed"
  }
  ```
- 步骤4：返回安全错误（SELECT * 会包含 password 列）
- 步骤5：返回安全错误，提示 ssn 被封禁

**失败表现**
- 能查到 password 或 ssn 的值
- SELECT * 正常执行没有被拦截

---

#### 测试场景 C：空配置时不影响查询

**前置条件**
```bash
# 清除所有封禁配置
unset SECURITY_BLOCKED_TABLES
unset SECURITY_BLOCKED_COLUMNS
```

**测试步骤**
1. 重启服务
2. 发送查询："查询所有用户信息"

**预期结果**
- 正常返回数据，无安全错误

**失败表现**
- 报错提示某些表/列被封禁
- 配置为空时服务启动失败

---

### 1.3 EXPLAIN 策略控制

#### 测试场景 A：DISABLED 模式（默认）

**前置条件**
```bash
# 使用默认配置或显式设置
export SECURITY_EXPLAIN_POLICY=disabled
```

**测试步骤**
1. 重启服务
2. 直接发送 SQL："EXPLAIN SELECT * FROM orders"
3. 直接发送 SQL："EXPLAIN ANALYZE SELECT * FROM orders"

**预期结果**
- 步骤2和3都返回错误：
  ```json
  {
    "error": "SecurityViolationError",
    "message": "EXPLAIN statements are not allowed"
  }
  ```

**失败表现**
- EXPLAIN 语句被执行并返回执行计划

---

#### 测试场景 B：EXPLAIN_ONLY 模式

**前置条件**
```bash
export SECURITY_EXPLAIN_POLICY=explain_only
```

**测试步骤**
1. 重启服务
2. 发送 SQL："EXPLAIN SELECT * FROM orders"
3. 发送 SQL："EXPLAIN ANALYZE SELECT * FROM orders"

**预期结果**
- 步骤2：正常返回执行计划（不实际执行查询）
- 步骤3：返回错误
  ```json
  {
    "error": "SecurityViolationError",
    "message": "EXPLAIN ANALYZE is not allowed"
  }
  ```

**失败表现**
- EXPLAIN 被拒绝
- EXPLAIN ANALYZE 被允许执行

---

#### 测试场景 C：ENABLED 模式

**前置条件**
```bash
export SECURITY_EXPLAIN_POLICY=enabled
```

**测试步骤**
1. 重启服务
2. 发送 SQL："EXPLAIN SELECT * FROM orders"
3. 发送 SQL："EXPLAIN ANALYZE SELECT * FROM orders"

**预期结果**
- 步骤2：返回执行计划
- 步骤3：返回执行计划（包含实际执行时间）

**失败表现**
- 任一 EXPLAIN 语句被拒绝

---

## 二、弹性与可观测性

### 2.1 速率限制

#### 测试场景 A：LLM 调用限流

**前置条件**
```bash
# 设置 LLM 调用限制为每秒 2 次
export RESILIENCE_LLM_LIMIT=2
export RESILIENCE_LLM_WINDOW=1
```

**测试步骤**
1. 重启服务
2. 快速连续发送 5 个自然语言查询（需要 LLM 生成 SQL）
   ```
   请求1: "查询今日订单"
   请求2: "查询昨日订单"  
   请求3: "查询本周订单"
   请求4: "查询本月订单"
   请求5: "查询全部订单"
   ```
3. 记录每个请求的响应

**预期结果**
- 前 2 个请求正常返回
- 第 3-5 个请求返回限流错误：
  ```json
  {
    "error": "RateLimitExceededError",
    "message": "LLM rate limit exceeded",
    "details": {
      "limit": 2,
      "window_seconds": 1,
      "retry_after_seconds": 0.5
    }
  }
  ```
- 等待 1 秒后再发请求，恢复正常

**失败表现**
- 所有请求都正常执行，没有限流
- 限流后没有提示等待时间

---

#### 测试场景 B：数据库查询限流

**前置条件**
```bash
export RESILIENCE_QUERY_LIMIT=5
export RESILIENCE_QUERY_WINDOW=1
```

**测试步骤**
1. 重启服务
2. 快速连续发送 10 个相同的简单查询（如果支持直接 SQL 模式）
3. 或者发送 10 个会生成相同 SQL 的自然语言查询

**预期结果**
- 前 5 个请求正常
- 第 6-10 个请求返回限流错误

**失败表现**
- 所有请求都执行了
- 数据库连接池耗尽而不是优雅限流

---

#### 测试场景 C：限流禁用时无影响

**前置条件**
```bash
# 不设置限流配置，或设置为 0
unset RESILIENCE_LLM_LIMIT
unset RESILIENCE_QUERY_LIMIT
```

**测试步骤**
1. 重启服务
2. 快速发送 20 个请求

**预期结果**
- 所有请求正常处理（可能因其他资源限制变慢，但不会返回限流错误）

**失败表现**
- 返回限流错误
- 服务因未配置限流而启动失败

---

### 2.2 Metrics 指标

#### 测试场景 A：基本指标收集

**前置条件**
```bash
export OBSERVABILITY_METRICS_ENABLED=true
export OBSERVABILITY_METRICS_PORT=9090
```

**测试步骤**
1. 重启服务
2. 访问 `http://localhost:9090/metrics`，记录初始值
3. 发送 3 个成功的查询请求
4. 发送 1 个会触发安全错误的请求（如查询被封禁的表）
5. 再次访问 `http://localhost:9090/metrics`

**预期结果**
- 步骤2：能看到指标页面，初始值为 0
- 步骤5：能看到以下指标变化
  ```
  # 查询请求总数
  pg_mcp_query_requests_total 4
  
  # 成功查询数
  pg_mcp_query_success_total 3
  
  # 失败查询数
  pg_mcp_query_failure_total 1
  
  # 安全违规数
  pg_mcp_security_violations_total 1
  
  # 查询耗时（直方图，会有多个 bucket）
  pg_mcp_query_duration_seconds_bucket{le="0.1"} ...
  pg_mcp_query_duration_seconds_bucket{le="0.5"} ...
  ```

**失败表现**
- `/metrics` 端点返回 404
- 指标值始终为 0
- 缺少某些预期的指标

---

#### 测试场景 B：LLM 相关指标

**前置条件**
- 同场景A

**测试步骤**
1. 发送 2 个需要 LLM 生成 SQL 的自然语言查询
2. 访问 `/metrics`

**预期结果**
```
# LLM 调用次数
pg_mcp_llm_calls_total 2

# LLM 调用耗时
pg_mcp_llm_duration_seconds_sum > 0

# Token 使用量（如果 LLM 返回了这个信息）
pg_mcp_tokens_used_total > 0
```

**失败表现**
- LLM 相关指标缺失或为 0

---

#### 测试场景 C：Metrics 禁用时无影响

**前置条件**
```bash
export OBSERVABILITY_METRICS_ENABLED=false
```

**测试步骤**
1. 重启服务
2. 尝试访问 `http://localhost:9090/metrics`
3. 发送正常查询请求

**预期结果**
- 步骤2：连接被拒绝或返回错误（端口未监听）
- 步骤3：查询正常执行，无性能影响

**失败表现**
- Metrics 端口仍然在监听
- 查询因 metrics 相关代码报错

---

### 2.3 Tracing 追踪

#### 测试场景 A：Request ID 贯穿日志

**前置条件**
```bash
export OBSERVABILITY_LOG_LEVEL=DEBUG
export OBSERVABILITY_LOG_FORMAT=json
```

**测试步骤**
1. 重启服务
2. 发送一个查询请求
3. 查看服务日志输出

**预期结果**
- 该请求产生的所有日志行都包含相同的 `request_id`
- 日志示例：
  ```json
  {"timestamp": "...", "level": "INFO", "request_id": "abc-123", "message": "Received query request", ...}
  {"timestamp": "...", "level": "DEBUG", "request_id": "abc-123", "message": "Generating SQL...", ...}
  {"timestamp": "...", "level": "DEBUG", "request_id": "abc-123", "message": "Executing SQL...", ...}
  {"timestamp": "...", "level": "INFO", "request_id": "abc-123", "message": "Query completed", ...}
  ```

**失败表现**
- 部分日志没有 request_id
- 不同日志行的 request_id 不一致
- request_id 格式不是 UUID

---

#### 测试场景 B：外部 Request ID 透传

**前置条件**
- 同场景A

**测试步骤**
1. 发送请求时在 header 或参数中传入自定义 request_id
   ```json
   {
     "question": "查询订单",
     "request_id": "my-custom-trace-id-12345"
   }
   ```
2. 查看日志

**预期结果**
- 所有日志使用传入的 `my-custom-trace-id-12345` 而不是自动生成的 UUID

**失败表现**
- 忽略传入的 request_id，使用自动生成的
- 传入 request_id 导致报错

---

## 三、模型缺陷修复

### 3.1 QueryResponse.to_dict 修复

#### 测试场景 A：tokens_used 默认值

**测试步骤**
1. 发送一个查询请求
2. 检查响应 JSON

**预期结果**
- 响应中始终包含 `tokens_used` 字段
- 如果 LLM 没有返回 token 信息，值为 `0`
  ```json
  {
    "success": true,
    "result": {...},
    "sql": "SELECT ...",
    "tokens_used": 0,
    "confidence": 100
  }
  ```

**失败表现**
- 响应中缺少 `tokens_used` 字段
- `tokens_used` 为 `null`

---

#### 测试场景 B：tokens_used 实际值保留

**测试步骤**
1. 发送一个查询请求（LLM 应该返回 token 使用量）
2. 检查响应 JSON

**预期结果**
- 如果 LLM 返回了 token 信息（如 50），响应中显示实际值
  ```json
  {
    "tokens_used": 50
  }
  ```

**失败表现**
- 实际值被覆盖为 0
- 实际值被覆盖为 null

---

#### 测试场景 C：confidence 字段

**测试步骤**
1. 发送查询请求
2. 检查响应

**预期结果**
- 响应包含 `confidence` 字段，值为 0-100 之间的数字
- 默认值为 100

**失败表现**
- 缺少 confidence 字段
- confidence 为 null

---

## 四、测试检查清单

### 快速冒烟测试（5分钟）

| # | 测试项 | 操作 | 预期 | 结果 |
|---|--------|------|------|------|
| 1 | 服务启动 | 使用默认配置启动 | 无报错 | ☐ |
| 2 | 基本查询 | 发送简单查询 | 返回数据 | ☐ |
| 3 | Metrics 端点 | 访问 /metrics | 看到指标 | ☐ |
| 4 | 响应格式 | 检查响应 JSON | 包含 tokens_used | ☐ |

### 安全功能测试（10分钟）

| # | 测试项 | 操作 | 预期 | 结果 |
|---|--------|------|------|------|
| 1 | 表封禁生效 | 配置封禁表后查询 | 返回安全错误 | ☐ |
| 2 | 列封禁生效 | 配置封禁列后查询 | 返回安全错误 | ☐ |
| 3 | EXPLAIN 禁用 | 发送 EXPLAIN | 返回安全错误 | ☐ |
| 4 | 空配置兼容 | 不配置封禁 | 正常查询 | ☐ |

### 弹性功能测试（10分钟）

| # | 测试项 | 操作 | 预期 | 结果 |
|---|--------|------|------|------|
| 1 | LLM 限流 | 快速发送超限请求 | 返回限流错误 | ☐ |
| 2 | 查询限流 | 快速发送超限查询 | 返回限流错误 | ☐ |
| 3 | 限流恢复 | 等待后重试 | 恢复正常 | ☐ |
| 4 | 限流禁用 | 不配置限流 | 无限流错误 | ☐ |

### 可观测性测试（10分钟）

| # | 测试项 | 操作 | 预期 | 结果 |
|---|--------|------|------|------|
| 1 | 指标递增 | 发送请求后查 metrics | 计数增加 | ☐ |
| 2 | 错误指标 | 触发错误后查 metrics | 错误计数增加 | ☐ |
| 3 | Request ID | 查看日志 | ID 一致 | ☐ |
| 4 | Metrics 禁用 | 禁用后查端口 | 端口未监听 | ☐ |

### 多数据库测试（15分钟，如适用）

| # | 测试项 | 操作 | 预期 | 结果 |
|---|--------|------|------|------|
| 1 | 多库配置 | 配置两个库 | 启动成功 | ☐ |
| 2 | 指定库查询 | 指定 database 参数 | 查对应库 | ☐ |
| 3 | 默认库 | 不指定 database | 查默认库 | ☐ |
| 4 | 错误库名 | 指定不存在的库 | 返回错误+可用列表 | ☐ |
| 5 | 单库兼容 | 用旧配置方式 | 正常工作 | ☐ |

---

## 五、常见问题排查

### 服务启动失败

**症状**：启动时报配置错误

**排查步骤**：
1. 检查环境变量格式是否正确（JSON 需要正确转义）
2. 检查必填配置是否缺失
3. 查看启动日志的具体错误信息

### 限流不生效

**症状**：发送大量请求没有被限流

**排查步骤**：
1. 确认 `RESILIENCE_*` 环境变量已设置
2. 确认服务重启后配置生效
3. 检查日志是否有限流相关输出
4. 确认请求确实在时间窗口内（不是间隔太长）

### Metrics 全是 0

**症状**：`/metrics` 能访问但所有值都是 0

**排查步骤**：
1. 确认发送了实际的查询请求
2. 检查是否是改进前的版本（metrics 未接入）
3. 查看日志是否有 metrics 相关错误

### 安全封禁不生效

**症状**：配置了封禁但仍能查询

**排查步骤**：
1. 确认环境变量名称正确（`SECURITY_BLOCKED_TABLES`）
2. 确认服务重启了
3. 确认表名/列名拼写与数据库一致（区分大小写）
4. 检查生成的 SQL 是否确实包含被封禁的表/列

### Request ID 不一致

**症状**：同一请求的日志有不同的 request_id

**排查步骤**：
1. 确认是改进后的版本
2. 检查是否有并发请求混在一起
3. 按时间戳排序日志，确认是同一请求的日志